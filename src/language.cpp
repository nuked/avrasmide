/*
 *	language.cpp -- constant language definition things.
 *	Copyright (C) 2013 Gregoire Liglet and Florent Chiron, University of Kent.
 *	Copyright (C) 2013-2014 Fred Barnes, University of Kent <frmb@kent.ac.uk>
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "language.h"

const QMultiMap < QString, OpcodeInfo > OpcodesInfo = {
	// Map Key :  Name   ;  Params   ;  Description                                  ;    Operations (vector)                           ;  Flags               ; #Clocks
	{"ADD", {"ADD", "Rd, Rr", "Add without Carry", {"Rd ← Rd + Rr"}, "Z,C,N,V,S,H", "1"}},
	{"ADC", {"ADC", "Rd, Rr", "Add with Carry ", {"Rd ← Rd + Rr + C"}, "Z,C,N,V,S,H", "1"}},
	{"ADIW", {"ADIW", "Rd, K", "Add Immediate to Word", {"Rd ← Rd + 1:Rd + K"}, "Z,C,N,V,S", "2"}},
	{"SUB", {"SUB", "Rd, Rr", "Subtract without Carry", {"Rd ← Rd - Rr"}, "Z,C,N,V,S,H", "1"}},
	{"SUBI", {"SUBI", "Rd, K", "Subtract Immediate", {"Rd ← Rd - K"}, "Z,C,N,V,S,H", "1"}},
	{"SBC", {"SBC", "Rd, Rr", "Subtract with Carry ", {"Rd ← Rd - Rr - C"}, "Z,C,N,V,S,H", "1"}},
	{"SBCI", {"SBCI", "Rd, K", "Subtract Immediate with Carry", {"Rd ← Rd - K - C"}, "Z,C,N,V,S,H", "1"}},
	{"SBIW", {"SBIW", "Rd, K", "Subtract Immediate from Word", {"Rd + 1:Rd ← Rd + 1:Rd - K"}, "Z,C,N,V,S", "2"}},
	{"AND", {"AND", "Rd, Rr", "Logical AND ", {"Rd ← Rd • Rr"}, "Z,N,V,S", "1"}},
	{"ANDI", {"ANDI", "Rd, K", "Logical AND with Immediate", {"Rd ← Rd • K"}, "Z,N,V,S", "1"}},
	{"OR", {"OR", "Rd, Rr", "Logical OR ", {"Rd ← Rd v Rr"}, "Z,N,V,S", "1"}},
	{"ORI", {"ORI", "Rd, K", "Logical OR with Immediate", {"Rd ← Rd v K"}, "Z,N,V,S", "1"}},
	{"EOR", {"EOR", "Rd, Rr", "Exclusive OR ", {"Rd ← Rd ⊕ Rr"}, "Z,N,V,S", "1"}},
	{"COM", {"COM", "Rd", "One's Complement", {"Rd ← $FF - Rd"}, "Z,C,N,V,S", "1"}},
	{"NEG", {"NEG", "Rd", "Two's Complement", {"Rd ← $00 - Rd"}, "Z,C,N,V,S,H", "1"}},
	{"SBR", {"SBR", "Rd,K", "Set Bit(s) in Register", {"Rd ← Rd v K"}, "Z,N,V,S", "1"}},
	{"CBR", {"CBR", "Rd,K", "Clear Bit(s) in Register", {"Rd ← Rd • ($FFh - K)"}, "Z,N,V,S", "1"}},
	{"INC", {"INC", "Rd", "Increment", {"Rd ← Rd + 1"}, "Z,N,V,S", "1"}},
	{"DEC", {"DEC", "Rd", "Decrement", {"Rd ← Rd - 1"}, "Z,N,V,S", "1"}},
	{"TST", {"TST", "Rd", "Test for Zero or Minus", {"Rd ← Rd • Rd"}, "Z,N,V,S", "1"}},
	{"CLR", {"CLR", "Rd", "Clear Register", {"Rd ← Rd ⊕ Rd"}, "Z,N,V,S", "1"}},
	{"SER", {"SER", "Rd", "Set Register", {"Rd ← $FF"}, "None", "1"}},
	{"MUL", {"MUL", "Rd, Rr", "Multiply Unsigned", {"R1:R0 ← Rd x Rr (UU)"}, "Z,C", "2"}},
	{"MULS", {"MULS", "Rd, Rr", "Multiply Signed", {"R1:R0 ← Rd x Rr (SS)"}, "Z,C", "2"}},
	{"MULSU", {"MULSU", "Rd, Rr", "Multiply Signed with Unsigned", {"R1:R0 ← Rd x Rr (SU)"}, "Z,C", "2"}},
	{"FMUL", {"FMUL", "Rd, Rr", "Fractional Multiply Unsigned", {"R1:R0 ← Rd x Rr<<1 (UU)"}, "Z,C", "2"}},
	{"FMULS", {"FMULS", "Rd, Rr", "Fractional Multiply Signed", {"R1:R0 ← Rd x Rr<<1 (SS)"}, "Z,C", "2"}},
	{"FMULSU", {"FMULSU", "Rd, Rr", "Fractional Multiply Signed with Unsigned", {"R1:R0 ← Rd x Rr<<1 (SU)"}, "Z,C", "2"}},
	{"RJMP", {"RJMP", "k", "Relative Jump", {"PC ← PC + k + 1"}, "None", "2"}},
	{"IJMP", {"IJMP", "", "Indirect Jump to (Z)", {"PC(15:0) ← Z,", "PC(21:16) ← 0"}, "None", "2"}},
	{"EIJMP", {"EIJMP", "", "Extended Indirect Jump to (Z)", {"PC(15:0) ← Z,", "PC(21:16) ← EIND"}, "None", "2"}},
	{"JMP", {"JMP", "k", "Jump", {"PC ← k"}, "None", "3"}},
	{"RCALL", {"RCALL", "k", "Relative Call Subroutine ", {"PC ← PC + k + 1"}, "None", "3 / 4"}},
	{"ICALL", {"ICALL", "", "Indirect Call to (Z)", {"PC(15:0) ← Z,", "PC(21:16) ← 0"}, "None", "3 / 4"}},
	{"EICALL", {"EICALL", "", "Extended Indirect Call to (Z)", {"PC(15:0) ← Z,", "PC(21:16) ← EIND"}, "None", "4"}},
	{"CALL", {"CALL", "k", "call Subroutine", {"PC ← k"}, "None", "4 / 5"}},
	{"RET", {"RET", "", "Subroutine Return", {"PC ← STACK"}, "None", "4 / 5"}},
	{"RETI", {"RETI", "", "Interrupt Return", {"PC ← STACK"}, "I", "4 / 5"}},
	{"CPSE", {"CPSE", "Rd, Rr", "Compare, Skip if Equal", {"if (Rd = Rr) PC ← PC + 2 or 3"}, "None", "1 / 2 / 3"}},
	{"CP", {"CP", "Rd, Rr", "Compare", {"Rd - Rr"}, "Z,C,N,V,S,H", "1"}},
	{"CPC", {"CPC", "Rd, Rr", "Compare with Carry", {"Rd - Rr - C"}, "Z,C,N,V,S,H", "1"}},
	{"CPI", {"CPI", "Rd, K", "Compare with Immediate", {"Rd - K"}, "Z,C,N,V,S,H", "1"}},
	{"SBRC", {"SBRC", "Rr, b", "Skip if Bit in Register Cleared", {"if (Rr(b) = 0) PC ← PC + 2 or 3"}, "None", "1 / 2 / 3"}},
	{"SBRS", {"SBRS", "Rr, b", "Skip if Bit in Register Set", {"if (Rr(b) = 1) PC ← PC + 2 or 3"}, "None", "1 / 2 / 3"}},
	{"SBIC", {"SBIC", "A, b", "Skip if Bit in I/O Register Cleared", {"if (I/O(A,b) = 0) PC ← PC + 2 or 3"}, "None", "1 / 2 / 3"}},
	{"SBIS", {"SBIS", "A, b", "Skip if Bit in I/O Register Set", {"If (I/O(A,b) =1) PC ← PC + 2 or 3"}, "None", "1 / 2 / 3"}},
	{"BRBS", {"BRBS", "s, k", "Branch if Status Flag Set", {"if (SREG(s) = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRBC", {"BRBC", "s, k", "Branch if Status Flag Cleared", {"if (SREG(s) = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BREQ", {"BREQ", "k", "Branch if Equal ", {"if (Z = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRNE", {"BRNE", "k", "Branch if Not Equal", {"if (Z = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRCS", {"BRCS", "k", "Branch if Carry Set", {"if (C = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRCC", {"BRCC", "k", "Branch if Carry Cleared", {"if (C = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRSH", {"BRSH", "k", "Branch if Same or Higher ", {"if (C = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRLO", {"BRLO", "k", "Branch if Lower", {"if (C = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRMI", {"BRMI", "k", "Branch if Minus", {"if (N = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRPL", {"BRPL", "k", "Branch if Plus ", {"if (N = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRGE", {"BRGE", "k", "Branch if Greater or Equal, Signed", {"if (N ⊕ V= 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRLT", {"BRLT", "k", "Branch if Less Than, Signed", {"if (N ⊕ V= 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRHS", {"BRHS", "k", "Branch if Half Carry Flag Set", {"if (H = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRHC", {"BRHC", "k", "Branch if Half Carry Flag Cleared", {"if (H = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRTS", {"BRTS", "k", "Branch if T Flag Set", {"if (T = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRTC", {"BRTC", "k", "Branch if T Flag Cleared", {"if (T = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRVS", {"BRVS", "k", "Branch if Overflow Flag is Set", {"if (V = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRVC", {"BRVC", "k", "Branch if Overflow Flag is Cleared", {"if (V = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRIE", {"BRIE", "k", "Branch if Interrupt Enabled", {"if (I = 1) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"BRID", {"BRID", "k", "Branch if Interrupt Disabled", {"if (I = 0) then PC ← PC + k + 1"}, "None", "1 / 2"}},
	{"MOV", {"MOV", "Rd, Rr", "Copy Register", {"Rd ← Rr"}, "None", "1"}},
	{"MOVW", {"MOVW", "Rd, Rr", "Copy Register Pair", {"Rd+1:Rd ← Rr+1:Rr"}, "None", "1"}},
	{"LDI", {"LDI", "Rd, K", "Load Immediate", {"Rd ← K"}, "None", "1"}},
	{"LDS", {"LDS", "Rd, k", "Load Direct from data space", {"Rd ← (k)"}, "None", "1"}},
	{"LD", {"LD", "Rd, X", "Load Indirect", {"Rd ← (X)"}, "None", "1"}},
	{"LD", {"LD", "Rd, X+", "Load Indirect and Post-Increment", {"Rd ← (X)", "X ← X + 1"}, "None", "2"}},
	{"LD", {"LD", "Rd, -X", "Load Indirect and Pre-Decrement", {"X ← X - 1,  ←  X - 1", "Rd ← (X)  ←  (X)"}, "None", "2"}},
	{"LD", {"LD", "Rd, Y", "Load Indirect", {"Rd ← (Y)  ←  (Y)"}, "None", "1"}},
	{"LD", {"LD", "Rd, Y+", "Load Indirect and Post-Increment", {"Rd ← (Y)", "Y ← Y + 1"}, "None", "2"}},
	{"LD", {"LD", "Rd, -Y", "Load Indirect and Pre-Decrement", {"Y ← Y - 1", "Rd ← (Y)"}, "None", "2"}},
	{"LD", {"LD", "Rd, Z", "Load Indirect ", {"Rd ← (Z)"}, "None", "1"}},
	{"LD", {"LD", "Rd, Z+", "Load Indirect and Post-Increment", {"Rd ← (Z),", "Z ← Z+1"}, "None", "2"}},
	{"LD", {"LD", "Rd, -Z", "Load Indirect and Pre-Decrement", {"Z ← Z - 1,", "Rd ← (Z)"}, "None", "2"}},
	{"LDD", {"LDD", "Rd, Y+q ", "Load Indirect with Displacement", {"Rd ← (Y + q)"}, "None", "2"}},
	{"LDD", {"LDD", "Rd, Z+q ", "Load Indirect with Displacement", {"Rd ← (Z + q)"}, "None", "2"}},
	{"STS", {"STS", "k, Rr", "Store Direct to Data Space", {"(k) ← Rd"}, "None", "1"}},
	{"ST", {"ST", "X, Rr", "Store Indirect", {"(X) ← Rr"}, "None", "1"}},
	{"ST", {"ST", "X+, Rr", "Store Indirect and Post-Increment", {"(X) ← Rr,", "X ← X + 1"}, "None", "1"}},
	{"ST", {"ST", "-X, Rr", "Store Indirect and Pre-Decrement", {"X ← X - 1,", "(X) ← Rr"}, "None", "2"}},
	{"ST", {"ST", "Y, Rr", "Store Indirect", {"(Y) ← Rr"}, "None", "1"}},
	{"ST", {"ST", "Y+, Rr", "Store Indirect and Post-Increment", {"(Y) ← Rr,", "Y ← Y + 1"}, "None", "1"}},
	{"ST", {"ST", "-Y, Rr", "Store Indirect and Pre-Decrement", {"Y ← Y - 1,", "(Y) ← Rr"}, "None", "2"}},
	{"ST", {"ST", "Z, Rr", "Store Indirect", {"(Z) ← Rr"}, "None", "1"}},
	{"ST", {"ST", "Z+, Rr", "Store Indirect and Post-Increment", {"(Z) ← Rr", "Z ← Z + 1"}, "None", "1"}},
	{"ST", {"ST", "-Z, Rr", "Store Indirect and Pre-Decrement", {"Z ← Z - 1"}, "None", "2"}},
	{"STD", {"STD", "Y+q, Rr", "Store Indirect with Displacement", {"(Y + q) ← Rr"}, "None", "2"}},
	{"STD", {"STD", "Z+q, Rr", "Store Indirect with Displacement", {"(Z + q) ← Rr"}, "None", "2"}},
	{"LPM", {"LPM", "", "Load Program Memory", {"R0 ← (Z)"}, "None", "3"}},
	{"LPM", {"LPM", "Rd, Z", "Load Program Memory", {"Rd ← (Z)"}, "None", "3"}},
	{"LPM", {"LPM", "Rd, Z+", "Increment", {"Rd ← (Z),", "Z ← Z + 1"}, "None", "3"}},
	{"ELPM", {"ELPM", "", "Extended Load Program Memory", {"R0 ← (RAMPZ:Z)"}, "None", "3"}},
	{"ELPM", {"ELPM", "Rd, Z", "Extended Load Program Memory", {"Rd ← (RAMPZ:Z)"}, "None", "3"}},
	{"ELPM", {"ELPM", "Rd, Z+", "Post-Increment", {"Rd ← (RAMPZ:Z),", "Z ← Z + 1"}, "None", "3"}},
	{"SPM", {"SPM", "", "Store Program Memory", {"(RAMPZ:Z) ← R1:R0"}, "None", "-"}},
	{"SPM", {"SPM", "Z+", "Store Program Memory and Post-Increment by 2", {"(RAMPZ:Z) ← R1:R0,", "Z ← Z + 2"}, "None", "-"}},
	{"IN", {"IN", "Rd, A", "In From I/O Location", {"Rd ← I/O(A)"}, "None", "1"}},
	{"OUT", {"OUT", "A, Rr", "Out To I/O Location", {"I/O(A) ← Rr"}, "None", "1"}},
	{"PUSH", {"PUSH", "Rr", "Push Register on Stack", {"STACK ← Rr"}, "None", "2"}},
	{"POP", {"POP", "Rd", "Pop Register from Stack", {"Rd ← STACK"}, "None", "2"}},
	{"XCH", {"XCH", "Z, Rd", "Exchange", {"(Z) ← Rd,", "Rd ← (Z) "}, "None", "1"}},
	{"LAS", {"LAS", "Z, Rd", "Load and Set", {"(Z) ← Rd v (Z)", "Rd ← (Z)"}, "None", "1"}},
	{"LAC", {"LAC", "Z, Rd", "Load and Clear", {"(Z) ← ($FF – Rd) • (Z)", "Rd ← (Z) "}, "None", "1"}},
	{"LAT", {"LAT", "Z, Rd", "Load and Toggle", {"(Z) ← Rd ⊕ (Z)", "Rd ← (Z)"}, "None", "1"}},
	{"LSL", {"LSL", "Rd", "Logical Shift Left", {"Rd(n+1) ← Rd(n),", "Rd(0) ← 0,", "C ← Rd(7)"}, "Z,C,N,V,H", "1"}},
	{"LSR", {"LSR", "Rd", "Logical Shift Right", {"Rd(n) ← Rd(n+1),", "Rd(7) ← 0,", "C ← Rd(0)"}, "Z,C,N,V", "1"}},
	{"ROL", {"ROL", "Rd", "Rotate Left Through Carry", {"Rd(0) ← C,", "Rd(n+1) ← Rd(n),", "C ← Rd(7)"}, "Z,C,N,V,H", "1"}},
	{"ROR", {"ROR", "Rd", "Rotate Right Through Carry", {"Rd(7) ← C,", "Rd(n) ← Rd(n+1),", "C ← Rd(0)"}, "Z,C,N,V", "1"}},
	{"ASR", {"ASR", "Rd", "Arithmetic Shift Right", {"Rd(n) ← Rd(n+1), n=0..6"}, "Z,C,N,V", "1"}},
	{"SWAP", {"SWAP", "Rd", "Swap Nibbles", {"Rd(3..0) ↔ Rd(7..4)"}, "None", "1"}},
	{"BSET", {"BSET", "s", "Flag Set", {"SREG(s) ← 1"}, "SREG(s)", "1"}},
	{"BCLR", {"BCLR", "s", "Flag Clear", {"SREG(s) ← 0"}, "SREG(s)", "1"}},
	{"SBI", {"SBI", "A, b", "Set Bit in I/O Register", {"I/O(A, b) ← 1"}, "None", "1"}},
	{"CBI", {"CBI", "A, b", "Clear Bit in I/O Register", {"I/O(A, b) ← 0"}, "None", "1"}},
	{"BST", {"BST", "Rr, b", "Bit Store from Register to T", {"T ← Rr(b)"}, "T", "1"}},
	{"BLD", {"BLD", "Rd, b", "Bit load from T to Register", {"Rd(b) ← T"}, "None", "1"}},
	{"SEC", {"SEC", "", "Set Carry", {"C ← 1"}, "C", "1"}},
	{"CLC", {"CLC", "", "Clear Carry", {"C ← 0"}, "C", "1"}},
	{"SEN", {"SEN", "", "Set Negative Flag", {"N ← 1"}, "N", "1"}},
	{"CLN", {"CLN", "", "Clear Negative Flag", {"N ← 0"}, "N", "1"}},
	{"SEZ", {"SEZ", "", "Set Zero Flag", {"Z ← 1"}, "Z", "1"}},
	{"CLZ", {"CLZ", "", "Clear Zero Flag", {"Z ← 0"}, "Z", "1"}},
	{"SEI", {"SEI", "", "Global Interrupt Enable", {"I ← 1"}, "I", "1"}},
	{"CLI", {"CLI", "", "Global Interrupt Disable", {"I ← 0"}, "I", "1"}},
	{"SES", {"SES", "", "Set Signed Test Flag", {"S ← 1"}, "S", "1"}},
	{"CLS", {"CLS", "", "Clear Signed Test Flag", {"S ← 0"}, "S", "1"}},
	{"SEV", {"SEV", "", "Set Two's Complement Overflow", {"V ← 1"}, "V", "1"}},
	{"CLV", {"CLV", "", "Clear Two's Complement Overflow", {"V ← 0"}, "V", "1"}},
	{"SET", {"SET", "", "Set T in SREG", {"T ← 1"}, "T", "1"}},
	{"CLT", {"CLT", "", "Clear T in SREG", {"T ← 0"}, "T", "1"}},
	{"SEH", {"SEH", "", "Set Half Carry Flag in SREG", {"H ← 1"}, "H", "1"}},
	{"CLH", {"CLH", "", "Clear Half Carry Flag in SREG", {"H ← 0"}, "H", "1"}},
	{"BREAK", {"BREAK", "", "Break", {"(See specific descr. for BREAK)"}, "None", "1"}},
	{"NOP", {"NOP", "", "No Operation", {}, "None", "1"}},
	{"SLEEP", {"SLEEP", "", "Sleep", {"(see specific descr. for Sleep)"}, "None", "1"}}
};

const QMap < QString, DirectiveInfo > DirectivesInfo = {
	{".const",
	 {".const", "expr [ , expr [ ... ] ]", "Constant data (in text or eeprom sections), given as a comma-separated list of 8-bit values).", ".const 5, \"hello\", 0x00"}},
	{".const16", {".const16", "expr [ , expr [ ... ] ]", "Similar to .const, but writes in 16-bit quantities rather than 8-bit ones.", ".const16 0xbeef, 0xf00d"}},
	{".data", {".data", "", "Indicates that what follows should go into the data (SRAM) section."
		   " Note that no code or constant data can be placed here (not building-in SRAM initialisation, yet).", ".data"}},
	{".def", {".def", "name = reg-expr", "Defines (specifically) a register name, that will undergo literal substitution (for reg-expr).", ".def XH = r27"}},
	{".endmacro", {".endmacro", "", "End of macro definition.", ".endmacro"}},
	{".equ", {".equ", "name = expr", "Defines an assembler program constant, that will undergo literal substitution for the given expression expr.", ".equ RAMSTART = 0x100"}},
	{".eeprom", {".eeprom", "", "Indicates that what follows should go into the eeprom (EEPROM) section.", ".eeprom"}},
	{".include",
	 {".include", "string", "Includes another file at the indicated point. The compiler's IPATHs will be searched for this file by default.", ".include \"atmega328.inc\""}},
	{".macro", {".macro", "name [ ( param-name [ , ... ] ) ]", "Start of macro definition.", ".macro BitSet (Port, Bit)"}},
	{".mcu", {".mcu", "string", "Sets the MCU type (string), case insensitive match against a list of MCUs the compiler knows about.", ".mcu \"atmega328\""}},
	{".org", {".org", "uint16", "Specifies the origin (address) for what follows.", ".org 0"}},
	{".space", {".space", "uint16", "Reserves the specified amount of space (in bytes). In the text section, this will be padded to 16-bits.", ".space 2"}},
	{".text", {".text", "", "Indicates that what follows should go into the text (code) section.", ".text"}},
};


